// Chapter 3: 建構與解構 (Constructor & Destructor)

// 1. 為什麼需要這一章？
// 回想一下你在 C 語言寫 struct 的時候，是不是常發生這種事：
// 宣告了一個結構變數（比如 Student s;）。
// 忘記給它初始值（忘記寫 s.score = 0;）。
// 結果程式跑出來分數是 32767 這種亂碼。
// C++ 覺得「人一定會犯錯」，所以它決定把「初始化」這件事變成強制且自動的。

// 2. 建構子 (Constructor) —— 物件的出生證明
// 當你建立一個物件（變數）的時候，C++ 會自動幫你執行一個函式，這個函式就叫「建構子」。
// 它的任務：確保物件一出生，資料就是乾淨、正確的（比如餘額一定是 0，不會是亂碼）。
// 它的特徵：
// a. 函式名稱 = 類別名稱。
// b. 沒有回傳值（連 void 都不用寫）。
// c. 不能手動呼叫，是物件「誕生」時系統自動觸發的。

// 3. 解構子 (Destructor) —— 物件的死亡證明
// 當這個物件用完了（比如函式結束了，變數要消失了），C++ 會自動幫你執行另一個函式，這個函式就叫「解構子」。
// 它的任務：收尾。比如關閉檔案、釋放記憶體。
// 它的特徵：
// a. 函式名稱 = ~ + 類別名稱。
// b. 一樣沒有回傳值。
// c. 不能手動呼叫，是物件「死亡」時系統自動觸發的。

// 程式碼範例：帶著帽子的寵物
#include <iostream>
#include <cstdlib>  // malloc, free
using namespace std;
class pet {
// Class 的預設屬性是 private
// 如果你把 public: 拿掉，所有的變數、建構子、函式都會自動變成 private。
public:
    int *hat;  // 這是一個指標，代表帽子

    // 【建構子】：出生時，順便去買帽子
    pet() {
        hat = (int*)malloc(sizeof(int));
        *hat = 100;
        cout << "寵物出生了，買了一頂帽子 (地址: " << hat << ")" << endl;
    }
    // 【解構子】：死亡時，要先處理帽子
    ~pet() {
        // 為什麼要 free?
        // 因為 C++ 系統只知道要回收 "Pet" 本身，
        // 系統不知道 "hat" 指標連去的那塊記憶體該怎麼辦。
        free(hat);
        cout << "寵物死掉了，帽子也順便燒給它了" << endl;
    }
};
int main() {
    if (true) {
        pet myPet; // 變數 myPet 誕生
        // ... 在這裡 myPet 活著，帽子也在 ...
    } 
    // 離開大括號 -> myPet 要消失了 -> 自動呼叫 ~Pet()
    
    return 0;
}
// 1. myPet (物件本身)：
// 存放在 Stack
// 包含一個指標變數 hat。
// C++ 負責管理：函式結束時，C++ 會自動回收這塊 myPet 的空間。
// 2. *hat (指標指到的東西)：
// 存放在 Heap (堆)。
// 這是你用 malloc 要來的。
// C++ 不負責管理：C++ 認為這是你跟 OS 借的，你要自己還。

// 結論：解構子 ~Pet() 的作用是：「當 myPet (Stack) 即將被系統回收時
// 給我一個機會執行最後一段程式碼。」
// 如果你在裡面寫了 free(hat) -> 你把 Heap 的資料清乾淨了 -> 安全。
// 如果你沒寫 free(hat) -> 系統把 myPet 回收了 -> Heap 那塊記憶體就變成無主孤魂了 (Memory Leak)。


// 補充 : 為什麼這行(int *hat)是用指標，而不是參考
// 理由一：參考 (Reference) 不能是「空的」 (Nullability)
// 指標：可以是 nullptr (空指標)。
// 參考：必須綁定一個存在的東西。
// 場景： 假設這隻 Pet 剛出生的時候可能還沒買帽子（或者帽子弄丟了）。
// 用指標：hat = nullptr; （合法！表示沒戴帽子）。
// 用參考：int &hat = ??? （報錯！你不能宣告一個參考但不給它目標）。
// 在資料結構中，這一點更重要。像是 Linked List 的結尾必須是 NULL，如果是 Reference 就做不到「結尾」這種狀態了。

// 理由二：參考 (Reference) 不能「換人」 (Reseatability)
// 這是最關鍵的原因。我們說過 Reference 是「死忠粉」
// 指標：今天指 A，明天可以改指 B。
// 參考：一出生綁定 A，這輩子就只能是 A 的分身。

// 理由三：malloc/new 回傳的就是「地址」
// 這是一個技術上的現實問題。
// 系統函式 malloc 回傳的是什麼？ 是一個地址 (void*)。
// C++ 運算子 new 回傳的是什麼？ 也是一個地址。
// 指標 (*) 就是專門用來裝「地址」的容器。 參考 (&) 是用來當「別名」的。
